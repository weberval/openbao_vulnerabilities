name: Govulncheck to GitHub Issues

on:
  schedule:
    - cron: '0 0 * * *' # Runs daily at midnight
  workflow_dispatch:

jobs:
  # Job 1: Read the configuration file and generate the job matrix
  load-targets:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
    steps:
      - name: Checkout Configuration
        uses: actions/checkout@v4

      - name: Load Repository List
        id: set-matrix
        run: |
          if [ ! -f repositories.json ]; then
            echo "::error::repositories.json not found."
            exit 1
          fi
          # Read the JSON file and output it as a compact string for the matrix
          MATRIX_JSON=$(jq -c . repositories.json)
          echo "matrix=$MATRIX_JSON" >> $GITHUB_OUTPUT

  # Job 2: Run the scan for each repository in parallel
  scan-repository:
    needs: load-targets
    runs-on: ubuntu-latest
    permissions:
      issues: write
      contents: read
    strategy:
      fail-fast: false # If one scan fails, don't stop the others
      max-parallel: 5   # Limit parallelism to avoid rate limiting on Issue creation
      matrix:
        repo: ${{ fromJson(needs.load-targets.outputs.matrix) }}

    steps:
      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: 'stable'

      - name: Install govulncheck
        run: go install golang.org/x/vuln/cmd/govulncheck@latest

      - name: Scan Repository
        id: scan
        run: |
          TARGET_REPO="${{ matrix.repo }}"
          echo "------------------------------------------------------"
          echo "Scanning: $TARGET_REPO"
          echo "------------------------------------------------------"

          # Clone the target repository
          git clone --depth 1 "https://github.com/$TARGET_REPO.git" target-source || { echo "Failed to clone $TARGET_REPO"; exit 1; }

          pushd target-source > /dev/null
          # Run govulncheck with -format json
          # We capture exit code but assume success for pipeline continuation
          govulncheck -format json ./... > ../govuln-stream.json || true
          popd > /dev/null

          # Initialize result files
          echo "[]" > govuln-results.json
          
          # Consolidate the streaming JSON objects into a single JSON array if the file is not empty
          if [ -s govuln-stream.json ]; then
            jq -s '.' govuln-stream.json > govuln-results.json
          fi

      - name: Process and Report Findings
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TARGET_REPO: ${{ matrix.repo }}
          REPORT_REPO: ${{ github.repository }}
        run: |
          # 1. Fetch ALL existing open issues for this Target Repo
          echo "Fetching existing issues..."
          gh issue list \
            --repo "$REPORT_REPO" \
            --label "govulncheck" \
            --search "$TARGET_REPO in:title" \
            --state open \
            --json number,title \
            --limit 500 > open_issues.json

          # 2. Identify Current Vulnerabilities (Reachable only)
          # Filter specifically for traces that contain a 'position' field.
          AFFECTING_IDS=$(jq -r '.[] | select(.finding.trace[]?.position != null) | .finding.osv' govuln-results.json | sort -u)

          # File to keep track of issues that are still valid (active)
          touch active_issue_numbers.txt

          if [ -n "$AFFECTING_IDS" ]; then
            for ID in $AFFECTING_IDS; do
              # Extract metadata (first occurrence of the OSV definition)
              VULN_DATA=$(jq -c ".[] | select(.osv != null and .osv.id == \"$ID\") | .osv" govuln-results.json | head -n 1)
              
              if [ -z "$VULN_DATA" ]; then continue; fi

              SUMMARY=$(echo "$VULN_DATA" | jq -r '.summary // "No summary available"')
              DETAILS=$(echo "$VULN_DATA" | jq -r '.details // "No details available"')
              
              # Extract fixed version from the finding object (if available)
              FIXED_VERSION=$(jq -r ".[] | select(.finding.osv == \"$ID\") | .finding.fixed_version // \"N/A\"" govuln-results.json | head -n 1)

              # Extract code positions, filtering for files present in the cloned repo
              POSITIONS=""
              # Get raw trace info: filename|line|function
              RAW_POSITIONS=$(jq -r ".[] | select(.finding.osv == \"$ID\") | .finding.trace[]? | select(.position != null) | \"\(.position.filename)|\(.position.line)|\(.function)\"" govuln-results.json | sort -u)
              
              while IFS='|' read -r FNAME LINE FUNC; do
                if [ -z "$FNAME" ]; then continue; fi
                # Check if file exists in the cloned repository (target-source)
                if [ -f "target-source/$FNAME" ]; then
                   POSITIONS+="- \`$FNAME:$LINE\` (Function: \`$FUNC\`)"$'\n'
                fi
              done <<< "$RAW_POSITIONS"

              if [ -z "$POSITIONS" ]; then
                  POSITIONS="_No specific lines in the scanned source code were identified (vulnerability likely in dependencies)._"
              fi

              TITLE="Security: $ID in $TARGET_REPO"
              
              # Construct Issue Body
              BODY=$(cat <<EOF
          ### govulncheck Finding (REACHABLE)
          - **Target Repository:** [$TARGET_REPO](https://github.com/$TARGET_REPO)
          - **Vulnerability ID:** [$ID](https://pkg.go.dev/vuln/$ID)
          - **Fixed In:** $FIXED_VERSION
          
          ### Summary
          $SUMMARY

          ### Details
          $DETAILS

          ### Affected Locations
          $POSITIONS

          ---
          *Note: govulncheck has confirmed that the source code in $TARGET_REPO contains a reachable call path to this vulnerability.*
          *Last Updated: $(date)*
          EOF
          )

              # Check if we already have an issue for this ID
              EXISTING_NUMBER=$(jq -r --arg title "$TITLE" '.[] | select(.title == $title) | .number' open_issues.json)

              if [ -n "$EXISTING_NUMBER" ]; then
                echo "Updating issue #$EXISTING_NUMBER for $ID..."
                gh issue edit "$EXISTING_NUMBER" --repo "$REPORT_REPO" --body "$BODY"
                echo "$EXISTING_NUMBER" >> active_issue_numbers.txt
              else
                echo "Creating new issue for $ID..."
                gh issue create --repo "$REPORT_REPO" --title "$TITLE" --body "$BODY" --label "security,govulncheck,vulnerability"
              fi
            done
          else
            echo "No reachable vulnerabilities found in this scan."
          fi

          # 3. Close Stale Issues
          # Check for issues that were in our initial list but NOT in active_issue_numbers.txt
          echo "Checking for fixed vulnerabilities..."
          
          jq -c '.[]' open_issues.json | while read -r issue_obj; do
            ISSUE_NUM=$(echo "$issue_obj" | jq -r '.number')
            ISSUE_TITLE=$(echo "$issue_obj" | jq -r '.title')
            
            # Double check title filter
            if [[ "$ISSUE_TITLE" != *"$TARGET_REPO"* ]]; then continue; fi

            if ! grep -q "^$ISSUE_NUM$" active_issue_numbers.txt; then
              echo "Closing issue #$ISSUE_NUM ($ISSUE_TITLE) as it is no longer detected."
              gh issue close "$ISSUE_NUM" --repo "$REPORT_REPO" --comment "Auto-closing: Vulnerability no longer detected in the latest scan of $TARGET_REPO."
            fi
          done
