name: Govulncheck to GitHub Issues

on:
  schedule:
    - cron: '0 0 * * *' # Runs daily at midnight
  workflow_dispatch:

jobs:
  # Job 1: Load list of repositories
  load-targets:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
    steps:
      - name: Checkout Configuration
        uses: actions/checkout@v4

      - name: Load Repository List
        id: set-matrix
        run: |
          if [ ! -f repositories.json ]; then
            echo "::error::repositories.json not found."
            exit 1
          fi
          # Read the JSON file and output it as a compact string for the matrix
          MATRIX_JSON=$(jq -c . repositories.json)
          echo "matrix=$MATRIX_JSON" >> $GITHUB_OUTPUT

  # Job 2: Scan repositories in parallel (Fan-Out)
  scan-repository:
    needs: load-targets
    runs-on: ubuntu-latest
    permissions:
      contents: read
    strategy:
      fail-fast: false
      matrix:
        repo: ${{ fromJson(needs.load-targets.outputs.matrix) }}
    steps:
      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: 'stable'

      - name: Install govulncheck
        run: go install golang.org/x/vuln/cmd/govulncheck@latest

      - name: Prepare Artifact Name
        run: |
          SAFE_NAME=$(echo "${{ matrix.repo }}" | tr '/' '-')
          echo "REPO_SAFE_NAME=$SAFE_NAME" >> $GITHUB_ENV

      - name: Scan Repository and Generate Report
        env:
          TARGET_REPO: ${{ matrix.repo }}
        run: |
          echo "------------------------------------------------------"
          echo "Scanning: $TARGET_REPO"
          echo "------------------------------------------------------"

          # 1. Clone the target repository
          git clone --depth 1 "https://github.com/$TARGET_REPO.git" target-source || { echo "Failed to clone $TARGET_REPO"; exit 1; }

          pushd target-source > /dev/null
          govulncheck -format json ./... > ../govuln-stream.json || true
          popd > /dev/null

          # Prepare default empty report if govulncheck produced no output
          if [ ! -s govuln-stream.json ]; then
            echo "{\"repo\": \"$TARGET_REPO\", \"findings\": []}" > "report-${REPO_SAFE_NAME}.json"
            exit 0
          fi

          # 2. Consolidate and Pre-process Data
          # Merge streaming output into a structured list of unique vulnerabilities
          jq -s '
            # Create lookup map for OSV definitions
            ([ .[] | select(.osv != null) | {key: .osv.id, value: .osv} ] | from_entries) as $osv_defs
            | 
            # Filter findings that have a trace with a position
            [ .[] | select(.finding.trace[]?.position != null) ]
            # Group by Vulnerability ID
            | group_by(.finding.osv)
            | map({
                id: .[0].finding.osv,
                fixed_version: (.[0].finding.fixed_version // "N/A"),
                summary: ($osv_defs[.[0].finding.osv].summary // "No summary available"),
                details: ($osv_defs[.[0].finding.osv].details // "No details available"),
                # Collect unique traces (file, line, function)
                traces: (map(.finding.trace[]? | select(.position != null) | {
                  file: .position.filename,
                  line: .position.line,
                  func: .function
                }) | unique)
              })
          ' govuln-stream.json > vulnerabilities.json

          # 3. Generate Findings Stream (Optimized Loop)
          # Iterate over vulnerabilities and verify file existence
          jq -c '.[]' vulnerabilities.json | while read -r VULN; do
            ID=$(echo "$VULN" | jq -r '.id')
            FIXED_VERSION=$(echo "$VULN" | jq -r '.fixed_version')
            SUMMARY=$(echo "$VULN" | jq -r '.summary')
            DETAILS=$(echo "$VULN" | jq -r '.details')
            
            POSITIONS=""
            
            # Check if referenced files exist in the cloned repo
            # We use a separate stream processing here to avoid subshell variable loss
            POSITIONS=$(echo "$VULN" | jq -c '.traces[]' | while read -r TRACE; do
              FNAME=$(echo "$TRACE" | jq -r '.file')
              LINE=$(echo "$TRACE" | jq -r '.line')
              FUNC=$(echo "$TRACE" | jq -r '.func')
              
              if [ -f "target-source/$FNAME" ]; then
                 echo "- \`$FNAME:$LINE\` (Function: \`$FUNC\`)"
              fi
            done)

            if [ -z "$POSITIONS" ]; then
                POSITIONS="_No specific lines in the scanned source code were identified (vulnerability likely in dependencies)._"
            fi

            TITLE="Security: $ID in $TARGET_REPO"
            
            BODY=$(cat <<EOF
          ### govulncheck Finding (REACHABLE)
          - **Target Repository:** [$TARGET_REPO](https://github.com/$TARGET_REPO)
          - **Vulnerability ID:** [$ID](https://pkg.go.dev/vuln/$ID)
          - **Fixed In:** $FIXED_VERSION
          
          ### Summary
          $SUMMARY

          ### Details
          $DETAILS

          ### Affected Locations
          $POSITIONS

          ---
          *Note: govulncheck has confirmed that the source code in $TARGET_REPO contains a reachable call path to this vulnerability.*
          *Last Updated: $(date)*
          EOF
          )
            # Output single JSON object to stdout
            jq -n --arg id "$ID" --arg title "$TITLE" --arg body "$BODY" \
               '{id: $id, title: $title, body: $body}'
          done > findings.jsonl

          # 4. Finalize Report
          # Slurp the JSONL stream into a single JSON array
          jq -s --arg repo "$TARGET_REPO" '{repo: $repo, findings: .}' findings.jsonl > "report-${REPO_SAFE_NAME}.json"

      - name: Upload Findings Artifact
        uses: actions/upload-artifact@v4
        with:
          name: findings-${{ env.REPO_SAFE_NAME }}
          path: report-${{ env.REPO_SAFE_NAME }}.json
          retention-days: 1

  # Job 3: Report Findings (Sequential Fan-In)
  report-findings:
    needs: scan-repository
    runs-on: ubuntu-latest
    permissions:
      issues: write
      contents: read
    steps:
      - name: Download All Artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: findings-*
          path: all-findings
          merge-multiple: true

      - name: Sync Issues
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPORT_REPO: ${{ github.repository }}
        run: |
          # Initialize tracking file for active issues once
          > active_issue_numbers.txt

          # Process all reports
          for REPORT_FILE in all-findings/*.json; do
            # Skip if no files match
            [ -e "$REPORT_FILE" ] || continue

            TARGET_REPO=$(jq -r '.repo' "$REPORT_FILE")
            echo "======================================================"
            echo "Processing findings for: $TARGET_REPO"
            echo "======================================================"

            # 1. Fetch existing issues for this Target Repo
            gh issue list \
              --repo "$REPORT_REPO" \
              --label "govulncheck" \
              --search "$TARGET_REPO in:title" \
              --state open \
              --json number,title > open_issues.json
            
            # 2. Process Findings
            jq -c '.findings[]' "$REPORT_FILE" | while read -r FINDING; do
              ID=$(echo "$FINDING" | jq -r '.id')
              TITLE=$(echo "$FINDING" | jq -r '.title')
              BODY=$(echo "$FINDING" | jq -r '.body')

              EXISTING_NUMBER=$(jq -r --arg title "$TITLE" '.[] | select(.title == $title) | .number' open_issues.json)

              if [ -n "$EXISTING_NUMBER" ] && [ "$EXISTING_NUMBER" != "null" ]; then
                echo "  [UPDATE] Issue #$EXISTING_NUMBER ($ID)"
                gh issue edit "$EXISTING_NUMBER" --repo "$REPORT_REPO" --body "$BODY"
                echo "$EXISTING_NUMBER" >> active_issue_numbers.txt
              else
                echo "  [CREATE] New Issue ($ID)"
                gh issue create --repo "$REPORT_REPO" --title "$TITLE" --body "$BODY" --label "security,govulncheck,vulnerability"
                sleep 1
              fi
            done

            # 3. Close Stale Issues
            jq -c '.[]' open_issues.json | while read -r OPEN_ISSUE; do
              ISSUE_NUM=$(echo "$OPEN_ISSUE" | jq -r '.number')
              ISSUE_TITLE=$(echo "$OPEN_ISSUE" | jq -r '.title')

              # Ensure we only touch issues for the current repo context
              if [[ "$ISSUE_TITLE" != *"$TARGET_REPO"* ]]; then continue; fi

              if ! grep -q "^$ISSUE_NUM$" active_issue_numbers.txt; then
                echo "  [CLOSE] Issue #$ISSUE_NUM (Fixed)"
                gh issue close "$ISSUE_NUM" --repo "$REPORT_REPO" --comment "Auto-closing: Vulnerability no longer detected in the latest scan of $TARGET_REPO."
                sleep 1
              fi
            done
          done
